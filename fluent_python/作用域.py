b = 6

def f1(a):
    print(a)
    print(b)
    b = 9

print(f1(3))
# 会报错


# 注意， 首先输出了 3， 这表明 print(a) 语句执行了。 但是第二个语句
# print(b) 执行不了。 一开始我很吃惊， 我觉得会打印 6， 因为有个全
# 局变量 b， 而且是在 print(b) 之后为局部变量 b 赋值的。
# 可事实是， Python 编译函数的定义体时， 它判断 b 是局部变量， 因为在
# 函数中给它赋值了。 生成的字节码证实了这种判断， Python 会尝试从本
# 地环境获取 b。 后面调用 f2(3) 时， f2 的定义体会获取并打印局部变
# 量 a 的值， 但是尝试获取局部变量 b 的值时， 发现 b 没有绑定值。
# 这不是缺陷， 而是设计选择： Python 不要求声明变量， 但是假定在函数
# 定义体中赋值的变量是局部变量。 这比 JavaScript 的行为好多了，
# JavaScript 也不要求声明变量， 但是如果忘记把变量声明为局部变量
# （ 使用 var） ， 可能会在不知情的情况下获取全局变量。

